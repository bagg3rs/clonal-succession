<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Clonal Succession - Contained Growth</title>
  <style>
    body {
      background: #111;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
      margin: 0;
    }
    canvas {
      border: 2px solid #555;
      border-radius: 10px;
      background: #222;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .stats {
      margin-top: 20px;
      display: flex;
      gap: 30px;
      font-size: 14px;
    }
    .stat-item {
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #ff4444;
    }
    .cage-stat {
      color: #00e676;
    }
    button {
      background: #333;
      color: white;
      border: 1px solid #555;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #444;
    }
    input[type="range"] {
      width: 100px;
    }
  </style>
</head>
<body>
  <div class="controls">
    <button onclick="toggleSimulation()">‚èØÔ∏è Play/Pause</button>
    <button onclick="resetSimulation()">üîÑ Reset</button>
    <label>Speed: <input type="range" id="speedControl" min="0.1" max="2" step="0.1" value="1" onchange="updateSpeed()"></label>
  </div>

  <canvas id="canvas" width="600" height="600"></canvas>

  <div class="stats">
    <div class="stat-item">
      <div class="stat-value" id="total-count">1</div>
      <div>Red Cells</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="divisions-left">25</div>
      <div>Divisions Left</div>
    </div>
    <div class="stat-item">
      <div class="stat-value cage-stat" id="cage-radius">18</div>
      <div>Cage Radius</div>
    </div>
    <div class="stat-item">
      <div class="stat-value" id="pressure">High</div>
      <div>Cell Pressure</div>
    </div>
  </div>

  <!-- Matter.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"></script>
  
  <script>
    // Matter.js setup
    const { Engine, Render, World, Bodies, Body, Events, Constraint, Vector } = Matter;
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Physics world setup
    const engine = Engine.create();
    const world = engine.world;
    engine.world.gravity.y = 0; // No gravity for cell simulation
    
    // Simulation parameters
    const CAGE_CENTER = { x: 300, y: 300 };
    let CAGE_RADIUS = 18;
    const MIN_CAGE_RADIUS = 18;
    const MAX_CAGE_RADIUS = 280;
    const CELL_RADIUS = 12;
    const MAX_CELLS = 100;
    
    let cells = [];
    let constraints = [];
    let boundaries = [];
    let divisionsLeft = 25;
    let generation = 1;
    let simulationRunning = true;
    let simulationSpeed = 1;
    let frameCount = 0;
    let targetCageRadius = CAGE_RADIUS;

    // Create MUCH stronger circular cage boundary
    function createCageBoundary(radius) {
      // Remove old boundaries
      if (boundaries.length > 0) {
        World.remove(world, boundaries);
        boundaries = [];
      }
      
      const segments = 32; // More segments for smoother boundary
      
      for (let i = 0; i < segments; i++) {
        const angle1 = (i / segments) * Math.PI * 2;
        const angle2 = ((i + 1) / segments) * Math.PI * 2;
        
        const x1 = CAGE_CENTER.x + Math.cos(angle1) * radius;
        const y1 = CAGE_CENTER.y + Math.sin(angle1) * radius;
        const x2 = CAGE_CENTER.x + Math.cos(angle2) * radius;
        const y2 = CAGE_CENTER.y + Math.sin(angle2) * radius;
        
        const wall = Bodies.rectangle(
          (x1 + x2) / 2, 
          (y1 + y2) / 2, 
          Vector.magnitude(Vector.sub({x: x2, y: y2}, {x: x1, y: y1})), 
          20, // MUCH thicker walls
          { 
            isStatic: true,
            angle: Math.atan2(y2 - y1, x2 - x1),
            render: { fillStyle: '#00e676' },
            restitution: 0.1, // Less bouncy to prevent escape
            friction: 0.9, // High friction
            frictionStatic: 0.9
          }
        );
        boundaries.push(wall);
      }
      
      World.add(world, boundaries);
      return boundaries;
    }

    // Calculate cell pressure
    function updateCagePressure() {
      if (cells.length === 0) return { pressure: 0, pressureLevel: "None" };
      
      let boundaryPressure = 0;
      let cellCrowding = 0;
      
      cells.forEach(cell => {
        const pos = cell.body.position;
        const distFromCenter = Vector.magnitude(Vector.sub(pos, CAGE_CENTER));
        
        // Count cells near boundary
        if (distFromCenter > CAGE_RADIUS - CELL_RADIUS - 3) {
          boundaryPressure += 1;
        }
        
        // Check for crowding
        cells.forEach(otherCell => {
          if (otherCell.id !== cell.id) {
            const otherPos = otherCell.body.position;
            const distance = Vector.magnitude(Vector.sub(otherPos, pos));
            if (distance < CELL_RADIUS * 2.0) {
              cellCrowding += 0.2;
            }
          }
        });
      });
      
      const pressure = boundaryPressure + (cellCrowding * 0.5) + (cells.length * 0.1);
      
      // Slower expansion
      const baseRadius = MIN_CAGE_RADIUS + (cells.length * 3);
      targetCageRadius = baseRadius;
      
      if (pressure > 2) {
        targetCageRadius += (pressure - 2) * 8;
      }
      
      targetCageRadius = Math.min(targetCageRadius, MAX_CAGE_RADIUS);
      
      // Slow expansion
      const expansionSpeed = 0.8;
      if (CAGE_RADIUS < targetCageRadius - 1) {
        CAGE_RADIUS += expansionSpeed;
        createCageBoundary(CAGE_RADIUS);
      } else if (CAGE_RADIUS > targetCageRadius + 3) {
        CAGE_RADIUS -= 0.2;
        createCageBoundary(CAGE_RADIUS);
      }
      
      let pressureLevel = "None";
      if (pressure > 6) pressureLevel = "Very High";
      else if (pressure > 4) pressureLevel = "High";
      else if (pressure > 2) pressureLevel = "Medium";
      else if (pressure > 0.5) pressureLevel = "Low";
      
      return { pressure, pressureLevel, boundaryPressure };
    }

    // Cell class with STRONG containment
    class Cell {
      constructor(x, y, generation = 1) {
        this.generation = generation;
        this.age = 0;
        this.maxAge = 500 + Math.random() * 200;
        this.canDivide = true;
        this.divisionCooldown = 0;
        this.isDividing = false;
        this.isNewborn = true;
        this.id = Math.random().toString(36).substr(2, 9);
        
        // Create physics body
        this.body = Bodies.circle(x, y, CELL_RADIUS, {
          restitution: 0.1, // Very low bounce
          friction: 0.9, // High friction
          frictionAir: 0.08, // More air resistance
          density: 0.002,
          render: { fillStyle: '#ff4444' }
        });
        
        // Add to world
        World.add(world, this.body);
        
        setTimeout(() => {
          this.isNewborn = false;
        }, 800);
      }

      update() {
        this.age++;
        
        if (this.divisionCooldown > 0) {
          this.divisionCooldown--;
          if (this.divisionCooldown === 0) {
            this.canDivide = true;
          }
        }
        
        // Strong cohesion
        this.strongCohesion();
        
        // FORCE cells back inside if they escape
        this.forceInsideCage();
      }
      
      strongCohesion() {
        const myPos = this.body.position;
        
        cells.forEach(otherCell => {
          if (otherCell.id !== this.id) {
            const otherPos = otherCell.body.position;
            const distance = Vector.magnitude(Vector.sub(otherPos, myPos));
            const idealDistance = CELL_RADIUS * 2.1;
            const cohesionRange = CELL_RADIUS * 6;
            
            if (distance < cohesionRange && distance > idealDistance) {
              const force = Vector.mult(
                Vector.normalise(Vector.sub(otherPos, myPos)), 
                0.0008
              );
              Body.applyForce(this.body, myPos, force);
            } else if (distance < idealDistance * 0.85) {
              const force = Vector.mult(
                Vector.normalise(Vector.sub(myPos, otherPos)), 
                0.0001
              );
              Body.applyForce(this.body, myPos, force);
            }
          }
        });
      }
      
      // STRONG containment force
      forceInsideCage() {
        const pos = this.body.position;
        const distFromCenter = Vector.magnitude(Vector.sub(pos, CAGE_CENTER));
        
        // If cell is outside or very close to boundary, force it back
        if (distFromCenter > CAGE_RADIUS - CELL_RADIUS) {
          // STRONG force back to center
          const forceToCenter = Vector.mult(
            Vector.normalise(Vector.sub(CAGE_CENTER, pos)), 
            0.005 // Much stronger containment force
          );
          Body.applyForce(this.body, pos, forceToCenter);
          
          // Also directly set position if way outside
          if (distFromCenter > CAGE_RADIUS + CELL_RADIUS) {
            const angle = Math.atan2(pos.y - CAGE_CENTER.y, pos.x - CAGE_CENTER.x);
            const newX = CAGE_CENTER.x + Math.cos(angle) * (CAGE_RADIUS - CELL_RADIUS - 2);
            const newY = CAGE_CENTER.y + Math.sin(angle) * (CAGE_RADIUS - CELL_RADIUS - 2);
            Body.setPosition(this.body, { x: newX, y: newY });
            Body.setVelocity(this.body, { x: 0, y: 0 }); // Stop movement
          }
        }
      }

      divide() {
        if (!this.canDivide || this.divisionCooldown > 0 || divisionsLeft <= 0 || cells.length >= MAX_CELLS) {
          return null;
        }
        
        this.isDividing = true;
        this.canDivide = false;
        this.divisionCooldown = 50;
        
        // Divide close to parent
        const angle = Math.random() * 2 * Math.PI;
        const distance = CELL_RADIUS * 2.05;
        
        let newX = this.body.position.x + Math.cos(angle) * distance;
        let newY = this.body.position.y + Math.sin(angle) * distance;
        
        // Make sure new cell is inside cage
        const distFromCenter = Math.sqrt((newX - CAGE_CENTER.x) ** 2 + (newY - CAGE_CENTER.y) ** 2);
        if (distFromCenter > CAGE_RADIUS - CELL_RADIUS - 2) {
          // Place new cell between parent and center instead
          const parentAngle = Math.atan2(this.body.position.y - CAGE_CENTER.y, this.body.position.x - CAGE_CENTER.x);
          newX = this.body.position.x - Math.cos(parentAngle) * distance;
          newY = this.body.position.y - Math.sin(parentAngle) * distance;
        }
        
        const newCell = new Cell(newX, newY, this.generation + 1);
        
        // Very gentle push
        const pushForce = Vector.mult(
          { x: Math.cos(angle), y: Math.sin(angle) }, 
          0.0003
        );
        Body.applyForce(newCell.body, newCell.body.position, pushForce);
        Body.applyForce(this.body, this.body.position, Vector.mult(pushForce, -1));
        
        // Strong constraint
        const constraint = Constraint.create({
          bodyA: this.body,
          bodyB: newCell.body,
          length: CELL_RADIUS * 2.1,
          stiffness: 0.8,
          damping: 0.4
        });
        
        World.add(world, constraint);
        constraints.push(constraint);
        
        setTimeout(() => {
          World.remove(world, constraint);
          const index = constraints.indexOf(constraint);
          if (index > -1) constraints.splice(index, 1);
        }, 2000);
        
        setTimeout(() => {
          this.isDividing = false;
        }, 800);
        
        divisionsLeft--;
        generation = Math.max(generation, newCell.generation);
        
        return newCell;
      }
      
      destroy() {
        World.remove(world, this.body);
      }
    }

    function initializeSimulation() {
      World.clear(world);
      cells = [];
      constraints = [];
      boundaries = [];
      
      CAGE_RADIUS = 18;
      targetCageRadius = CAGE_RADIUS;
      
      createCageBoundary(CAGE_RADIUS);
      
      const initialCell = new Cell(CAGE_CENTER.x, CAGE_CENTER.y, 1);
      cells.push(initialCell);
      
      divisionsLeft = 25;
      generation = 1;
      frameCount = 0;
    }

    function drawCells() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw cage outline
      ctx.strokeStyle = '#00e676';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(CAGE_CENTER.x, CAGE_CENTER.y, CAGE_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      
      // Draw target expansion
      if (Math.abs(CAGE_RADIUS - targetCageRadius) > 2) {
        ctx.strokeStyle = 'rgba(0, 230, 118, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.arc(CAGE_CENTER.x, CAGE_CENTER.y, targetCageRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw cells
      cells.forEach(cell => {
        const pos = cell.body.position;
        
        let fillStyle = '#ff4444';
        let strokeStyle = '#ff6666';
        let radius = CELL_RADIUS;
        
        // Check if cell is outside cage (shouldn't happen now)
        const distFromCenter = Vector.magnitude(Vector.sub(pos, CAGE_CENTER));
        if (distFromCenter > CAGE_RADIUS - CELL_RADIUS) {
          fillStyle = '#ff0000'; // Bright red if outside
          strokeStyle = '#ffffff'; // White border
        }
        
        if (cell.isNewborn) {
          const scale = Math.min(1, (800 - (cell.age * 4)) / 800 + 0.4);
          radius *= (0.4 + 0.6 * scale);
          fillStyle = '#ff6666';
        }
        
        if (cell.isDividing) {
          radius *= (1 + 0.1 * Math.sin(frameCount * 0.3));
          fillStyle = '#ff8888';
        }
        
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      });
      
      // Draw constraints
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 1;
      constraints.forEach(constraint => {
        if (constraint.bodyA && constraint.bodyB) {
          const posA = constraint.bodyA.position;
          const posB = constraint.bodyB.position;
          ctx.beginPath();
          ctx.moveTo(posA.x, posA.y);
          ctx.lineTo(posB.x, posB.y);
          ctx.stroke();
        }
      });
    }

    function divideCells() {
      if (divisionsLeft <= 0 || cells.length >= MAX_CELLS) return;
      
      const newCells = [];
      
      cells.forEach(cell => {
        if (Math.random() < 0.008 && cell.age > 25) {
          const newCell = cell.divide();
          if (newCell) {
            newCells.push(newCell);
          }
        }
      });
      
      cells.push(...newCells);
    }

    function updateCells() {
      cells.forEach(cell => cell.update());
    }

    function updateStats() {
      const pressureData = updateCagePressure();
      
      document.getElementById('total-count').textContent = cells.length;
      document.getElementById('divisions-left').textContent = divisionsLeft;
      document.getElementById('cage-radius').textContent = Math.round(CAGE_RADIUS);
      document.getElementById('pressure').textContent = pressureData.pressureLevel;
    }

    function gameLoop() {
      if (simulationRunning) {
        Engine.update(engine, 16.67 * simulationSpeed);
        
        updateCells();
        divideCells();
        
        drawCells();
        updateStats();
        
        frameCount++;
      }
      
      requestAnimationFrame(gameLoop);
    }

    function toggleSimulation() {
      simulationRunning = !simulationRunning;
    }

    function resetSimulation() {
      initializeSimulation();
    }

    function updateSpeed() {
      simulationSpeed = parseFloat(document.getElementById('speedControl').value);
    }

    initializeSimulation();
    gameLoop();
  </script>
</body>
</html>
